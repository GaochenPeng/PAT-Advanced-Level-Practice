# Summary
这题我感觉就迷的很。一开始我想到leetcode上好像做到过一道类似的，做法是两个链表一起遍历，链表1结束后从链表2开头继续，链表2结束后从链表1开头继续。这样所有结点都遍历后，如果两个有交叉，就会在交叉点停下，两个指针指向同一结点，否则就没有。  
但这样子只过了2个测试点，还有个超时。因为一开始我使用vector记录结点，每次寻找结点都是遍历一边，找到需要的。。。还有就是我判断是否所有结点遍历的依据是他给的n，但有可能n中有的结点在两条链表中都没有出现。。。  
后来我用STL中的MAP，超时问题是解决了。但还是要重新设计算法。  
看了网上的思路后用了先给第一条链表访问过的做标记，然后遍历第二条，找到做了标记的结点就是结果。  
这样子还是有个错，并且超时。。。  
想了好久后我发现原来他的输出要求补齐前面的0。。。。淦！  
并且超时那个我感觉是不是可能有循环，于是我在循环判断条件中加了判断是否到回路，结果就过了。但后来我再看网上的答案发现他们也并没有判断回路啊？？？我又感觉应该是和map下标不存在的时候会返回内容全为0的特性有关，但改成数组后还是一样。。。最后我发现，原来是我以为他不可能有一条输入一开始就是-1，于是就拿next是不是-1作为判断循环停止依据。但他真的有一个点是头就是-1。。。  
还有就是网上的一般做法是把用100000规模的数组下标作为哈希，这样就可以在O(1)时间找到结点。。。  
教训的话应该就是有hash的方法优先用hash，其次map，最后万不得已再用vector。。。  

# Summary
前序的第一个总是后续的最后一个，也就是当前根节点。中间的左半边是当前的左节点，右半边是右节点。去掉当前根节点后剩下的前序第一个在后续中的位置找到就是左子树。但如果在后续中是去掉当前节点的最后一个，那就不能判断是在左子树还是右子树。  
这个想到还是比较容易的。但我居然有一个点过不去。在许久的调试后我发现，由于我是使用返回值来判定是否是唯一的树，并且在过程中创建树。在左右两边都有子树的情况下需要进行递归创建以及判定。然后我就用了这样一句话：  
`bool isunique = createTree(&((*root)->left), lpre, lpost) && createTree(&((*root)->right), rpre, rpost)`  
并返回isunique。  
着乍一看好像没啥问题。但是如果左边子树不是唯一的，那么右边子树的创建过程就会被短路掉。  
这种bug真的特别难发现，还是得靠写的时候细心。  
我在代码中各处加入if语句和`while(1){continue;}`来通过OJ调试，最终确定了不过的点的一些信息:)。比如在接收n后写`if(n>15)while(1){continue;}`，并能够使用二分法最终确定n的值。  
我最后发现最终出来的树的结点比n要少，并且进一步找到了类似的情况（虽然和调试没什么关系，是瞎凑出来的。。。），然后进行跟踪终于找到bug。  
以后写代码还是要细心啊。。  
